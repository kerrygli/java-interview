## Java 并发

### 1.为什么会出现线程安全？

- cpu多级缓存导致的可见行；
- 线程切换导致的原子性；
- 编译优化导致的有序性。


### 2.CAS
乐观锁的一种实现。比较读和写两个时间点主内存中变量的值是否相等，
如果相等就把要修改的值写回主内存中，如果不相等就不做任何操作，修
改成功返回true，修改失败就返回false。

原理：假设内存中的原数据是V,旧的预期值是A，要修改的值是B.
A:主存——java进程中的内存，旧的预期值；
V：线程A工作线程(cpu寄存器)从主内存中读到线程的工作内存的值；
B:要修改成的新增。

如果V==A,则修改成功。

存在的ABA问题？
假设有两个线程，t1和t2,有一个共享变量x,初始值是A,t1线程想要修改成Z,
则t1线程需要先从主内存中读取x的值记录，之后使用cas判断当前x的值是否等
于A,如果为A修改为Z。但这个过程中可能t2线程先将x的值修改成了B,又将x的值
从B修改成了A,这就是CAS的ABA问题。

### 3.锁升级四种状态

- 无锁：没有对资源进行锁定，所有线程都能访问并修改同一资源，但同时只能
一个线程修改成功；

- 偏向锁：初次执行到sync的时候，锁对象变成偏向锁，即"偏向于第一个获得它的锁"
执行完同步代码块之后，线程并不会自动释放偏向锁，当同一个线程第二次访问的时候，就
会判断对象头中的线程是否为自己，不需要重新加锁，没有额外开销，性能高。

- 轻量级锁：指锁是偏向锁的时候，却被另外的线程访问，此时偏向锁就会升级为轻量级锁，
其他线程会通过自旋的形式尝试获取锁，线程不会阻塞，从而提高性能。

- 重量级锁：当线程锁竞争情况严重，某个到达最大自旋次数的线程(默认10次)，会将轻量级
锁升级为重量级锁(通过CAS修改锁标志位，但不修改持有但id)。当后续线程尝试获取锁时，就
将自己挂起，等待被唤醒。

### 4.死锁如何避免
死锁的原因：
- 一个资源每次只能被一个线程使用；
- 一个线程在阻塞等待某个资源时，不释放已占有的资源；
- 一个线程已经获得的资源，在为使用完成之前，不进行释放；
- 若干线程形成头尾相接的循环等待资源关系。

解决方案：
- 注意加锁顺序，保证每个线程按照同样的顺序进行加锁；
- 注意加锁的时限，可以针对锁设置一个超时时间。










