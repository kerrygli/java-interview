## Java基础


### 1.值传递
参数是基本数据类型，复制的是具体的值；如果参数是引用数据类型，把地址当成值，
复制的是地址；还有String类是一个非常特殊的类，它不可改变。

### 2.异常
Throwable是所有异常的父类
Error:严重错误，（内存溢出，系统崩溃）
Exception:
    运行时异常:运行时发生的异常（NPE,数组越界，参数非法）
    非运行时异常：必须处理（IOException,ClassNotFoundException）


### 3.hashCode与equals之间的关系
java中，每个对象都可以调用hashcode方法得到自己的哈希值，在一些集合类中，在比较两个对象
是否相等时，会先调用对象的hashCode方法进行hashCode比较，如果hashCode相同，则调用equals
进行比较，但该方法比较，所以通常先根据hashCode进行比较。

### 4.ConcurrentHashMap扩容机制
1.7版本：

1. 基于segment实现；
2. 每个segment相当于一个小型的hashMap;
3. 每个segment内部会进行扩容，扩容机制和hashMap一致；
4. 先生成新的数据（原来长度的2倍），然后转移元素到新数组中；
5. 扩容的机制也是每个segment单独判断的，判读是否超过了阈值。

1.8版本：
1. 不再基于segment实现；
2. 当某个线程进行put操作，如果返现正在扩容，则该线程一起加入进行扩容；
3. 如果某个线程put时，发现没有进行扩容，则将key-value添加到ConcurrentHashMap中，然后判断是否超过阈值；
4. 支持多个线程同时扩容；
5. 扩容之前先生成一个新到数组；
6. 在转移元素时，先将原来数组分组，将每组分给不同的线程来进行元素转移，每个线程负责一组或多组元素转移元素转移。

总结：
   HashTable虽然是一个线程安全的类，但是它用synchronized锁住整张hash表，相当于所有线程
   1.7主要采用分段锁，每个segment上同时只有一个线程可以操作，每个segment都类似
HashMap数组结构，可以扩容，发生冲突的时候可以转化为链表，但segment的个数一旦初始化就
不能改变。
   1.8采用Synchroinzed锁加cas的机制，结构由segment数组+hashEntry数组+链表进化成了Node数组+链表/红黑树。


### 5.hashmap从1.7到1.8底层有哪些变化？
1. 1.7底层是数组+链表；1.8底层是数组+链表+红黑树，主要为了提高HashMap插入和查询的效率；
2. 1.7链表主要采用头插法；1.8链表主要采用尾插法，因为1.8需要通过遍历统计元素的个数；
3. 1.7中的哈希算法比较复杂，存在各种右移与异或操作；1.8进行了简化，因为复杂的哈希算法是为
了提供散列性，由于新增了红黑树，可以适当简化哈希算法，节省cpu。




