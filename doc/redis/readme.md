
## redis 基础

### 1.基本数据类型
- String
- Hash
- List
- Set 
- SortedSet

1.1 底层实现

- String:简单动态字符串
 底层实现：一个字节数组buf,一个当前字符串长度的记录属性len,一个当前未使用
空间长度属性free。
 * 快速获取字符串长度；
 * 避免缓冲区溢出；
 * 直接使用预留缓冲区，避免内存的重新分配
 * 可以存放二进制数据
- Hash:压缩列表和哈希表
- List:双向链表和压缩列表
- Set:整数数组和哈希表
- Sorted Set:压缩列表和跳表
  * 跳表 有序单链表增加多级索引，方便快速定位。

为什么选择跳表而不是选择平衡树？



1.2 应用场景

- String:缓存数据，计数器，分布式锁;
- Hash:适合存放对象，比如把用户信息存放到hash里；
- List:消息队列，列表数据；
- Set:通过哈希表实现，用户标签，好友/关注/粉丝，交集或并集
- Zset:排行榜。

### 2.特殊数据类型
- BitMap:位图。简单理解为数组，只是里面的内容存0/1。
- Hyperlog:一种统计基数的数据集合。
- 布隆过滤器

### 3.持久化
3.1 RDB (redis database)
    
通过创建快照来获得存储在内存里的在某个时间段的数据副本。
Redis创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器
从而创建有相同数据到服务器副本。
    快照持久化是redis默认采用的持久化方式。

3.2 AOF（append of file）
    在执行重写命令时，redis服务器会维护一个AOF重写缓冲区，
该缓冲区会在子进程创建AOF文件期间，记录服务器执行的所有写命令。
当子进程完成创建新AOF文件的工作以后，服务器会将重写缓冲区中的
所有内容追加到新AOF文件到末尾，使得新的AOF文件保存的数据库状态
与现有的数据库状态一致。最后服务器用新的AOF文件替换旧的AOF文件，
以此来完成AOF重写操作。

### 4.过期策略
- 惰性删除
- 定期删除

### 5.内存淘汰策略
- volatile-lru
- volatile-ttl
- volatile-random

- allkeys-lru
- allkeys-random
- no-eviction:禁止驱逐数据，当内存不足的时候新写入会报错。

### 6.缓存雪崩/缓存击穿/缓存穿透

- 6.1 缓存雪崩：

    如果缓存在某一个时刻出现大规模key失效，就会导致大量请求到数据库上面，
可能导致数据库宕机。
    
    解决办法：1.对缓存失效时间增加随机数据，避免同一时间过期；
2.设置缓存永久不过期，通过定时任务进行数据更新。


- 6.2 缓存击穿：
    某个热点数据的key失效，就会造成大量请求直接打到db上。

    解决办法：

    1.设置热点数据永不过期；
    2.通过采用分布式锁控制某个key同一时间只运行一个线程查询数据，
其他线程等待。


- 6.3 缓存穿透
    非法的用户请求，无法命中缓存，会导致短时间内大量请求落在来数据库上，造成数据库压力过大。
    解决方案：1.存储空数据到缓存中；2.使用布隆过滤器


### 7. redis架构模式
- 单机模式
- 主从模式：
  可以支撑10w+并发，如果存储数据超过1T可以采用集群模式。

- 集群模式：目标扩展性，在单个redis内存不足到情况下，使用cluster进行分片存储。

- 哨兵模式：目标高可用，在master宕机时自动从slave选出master节点，继续提供服务。


哨兵选举过程：
    



7.1 集群hash槽为什么是16384？

   集群之间需要进行心跳通信，槽位太多消息头就会很大；
redis集群节点数量基本不可能超过1000个，节点过多会造成网络拥塞；
redis主节点的配置信息中，是通过bitmap的形式保存哈希槽。在传输
过程中会对bitmap进行压缩。填充率=slots/n(n表示节点数)，如果填充
率很高压缩率就很低，不利于心跳数据传输。

7.2 主从复制的原理
1. 当启动slave节点，它会发送一个psync命令给master节点；
2. 如果slave是重新连接，那么master节点仅仅复制新增的数据；
如果是首次连接那么会进行一次full resynchronization;
3. master会启动一个后台线程，开始生成一份RDB快照文件，同时还会
将客户端收到的命令缓存到内存中。RDB文件生成完毕之后，master会将这个RDB发送给
slave,slave会先写入磁盘，然后再从本地地盘加载到内存中。然后master会将内存中
缓存到数据发送给slave,slave也会同步这些数据。


### 8 redis6.0之前为什么采用单线程？之后为什么引入多线程？
- 单线程redis为什么执行这么快？
redis操作都在内存中完成；
单线程操作避免多线程之间读竞争；
采用多路复用I/O模式处理大量客户端socket请求。

- redis6.0对于网络I/O采用多线程，对于命令的执行仍然采用单线程，并不是有多线程。

### 9 如何保证缓存和数据库的一致性
1. 先更新缓存，再更新数据库；
2. 先更新数据库，再更新缓存；
3. 先删除缓存，再更新数据库；
4. 先更新数据库，再删除缓存。

推荐第4种方案，可以避免并发操作请求的情况下，出现缓存和数据库不一致的情况。但需要保证
更新数据库和删除缓存两个操作同时执行成功。
两个方案保证两种方案操作成功
- 引入mq进行消息重试，保证执行删除动作成功；
- 订阅Mysql binlog再操作缓存。
以上两种方案相同点：都采用异步都方式操作缓存。


### 10 redis大key如何处理
大key并不是指key很大，而是key对应的value很大。
一般以下两种情况被称为大key:
- String类型的值大于10KB;
- Hash,List,Set,ZSet类型元素个数超过5000个。


大key会带来4种影响：
1. 客户端超时阻塞；
2. 引发网络阻塞；
3. 阻塞工作线程；
4. 内存分布不均，集群模式下在slot分片均匀的情况下，会
造成查询倾斜，部分有大key的redis节点占用内存太多，qps也
会很高。








